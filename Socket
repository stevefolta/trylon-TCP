trylon Socket

new: port
	socket = Socket new: nil port: port string
	socket listen: default-backlog
	return socket

to: address port: port
	return Socket new: address string port: port string

close
accept



##### Implementation #####

fields socket

default-backlog = 128

c-preamble
	#include <sys/types.h>
	#include <sys/socket.h>
	#include <netdb.h>
	#include <string.h>

	static verify_socket(obj_ this_)
	{
		UsingMethod_(socket_not_open_error)
		if (Not_(Field_(socket)))
			Call_(socket_not_open_error, this_);
	}


c-fn create: address port: port
	struct addrinfo hints;
	struct addrinfo* addrResult;
	struct addrinfo* addr;
	int result;
	int socketID;
	UsingMethod_(address_error_co_)
	UsingMethod_(bind_error) UsingMethod_(connect_error)

	/* Get the address. */
	memset(&hints, 0, sizeof(struct addrinfo));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	if (address == nil)
		hints.ai_flags = AI_PASSIVE;
	result =
		getaddrinfo(
			(address ? CString_(address) : nil), 
			(port ? CString_(port) : nil),
			&hints, &addrResult);
	if (result != 0)
		Call_(address_error_co_, this_, BuildString_(gai_strerror(result)));
	
	/* Open the socket, using the address. */
	for (addr = addrResult; addr != nil; addr = addr->ai_next) {
		socketID = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
		if (socketID == -1)
			continue;

		if (address == nil) {
			/* This is a listening socket, so bind it. */
			result = bind(socketID, addr->ai_addr, addr->ai_addrlen);
			}
		else {
			/* This is a connecting socket, so connect. */
			result = connect(socketID, addr->ai_addr, addr->ai_addrlen);
			}
		if (result == 0)
			break;

		/* Failed, try again. */
		close(socketID);
		}

	freeaddrinfo(addrResult);

	/* Failed? */
	if (result != 0) {
		if (address == nil)
			Call_(bind_error, this_);
		else
			Call_(connect_error, this_);
		}

	/* Succeeded. */
	Field_(socket) = BuildInt_(socketID);


c-fn close
	if (Field_(socket)) {
		close(IntValue_(Field_(socket)));
		Field_(socket) = nil;
		}

destroy
	close


c-fn listen: backlog
	UsingMethod_(listen_error);
	int result;
	verify_socket(this_);
	result = listen(IntValue_(Field_(socket)), IntValue_(backlog));
	if (result != 0)
		Call_(listen_error, this_);

c-fn accept
	UsingMethod_(accept_error) UsingMethod_(new_for_socket_co_)
	int new_socket;
	verify_socket(this_);
	new_socket = accept(IntValue_(Field_(socket)), NULL, 0);
	if (new_socket == -1)
		Call_(accept_error, this_);
	return Call_(new_for_socket_co_, this_, BuildInt_(new_socket));


create-for-socket: socket
	this socket = socket


address-error: message
	error: ("Couldn't find address: ", message, ".")
socket-not-open-error
	error: "Socket is not open."
bind-error
	error: "Bind error."
connect-error
	error: "Connect error."
listen-error
	error: "Listen error."
accept-error
	error: "Accept error."


